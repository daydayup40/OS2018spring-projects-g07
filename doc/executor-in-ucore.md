## Executor in uCore

​	这篇文档主要讲述executor的原理、在uCore中移植的过程和结果。



## 1. 使用方式

​	Executor已经集成进了uCore的user-app中，因此按照编译uCore的方式直接编译即可。运行uCore之后，其二进制文件将会出现在/bin文件夹下，可以通过shell直接运行（虽然如此单独运行并无意义）



## 2. Executor 原理

​	executor程序的功能主要是在目标操作系统中，建立起环境并系统调用fuzzer生成的系统调用测试数据，返回结果。Syzkaller中为多种操作系统提供了executor，其中linux系统由于本身具有较多的内核调试模块，且是Syzkaller项目主要的目标，因此相应的executor功能最为齐全。此外，linux系统和uCore操作系统在系统调用和内核实现上都有着极高的相似度，综合以上原因，我们最终选取了linux系统使用的executor作为移植对象。下面将详细讲述这一版executor的大致实现方式：

​	executor涉及到很多基本的系统调用，为求方便，采用了C++语言实现（这对于uCore和我们来说颇有好处，因为uCore支持C，且executor设计的C++语法不多）。程序一共会生成三层进程来完成整体的测试功能，我们分别将其称为起始进程、Sandbox进程和Execute进程。

### 起始进程

​	建立和fuzzer的通信机制（和fuzzer握手），建立运行环境（包括创建工作文件夹，设置权限等），建立运行测试用例的Sandbox进程，然后等待。

### Sandbox进程

​	该进程在创建后，设定好内部环境，然后开始和fuzzer进行交互。fuzzer在这一阶段会以execute指令的形式向Sandbox传递内容，而每一个execute指令中会包含一系列的Syscall和数据读写操作。当Sandbox进程收到execute指令后，会fork出一个子进程，然后进入等待

### execute进程

​	一个该进程和一个execute相对应，它通过之前建立的通信机制，它会不断的从fuzzer读取调用指令，同时建立起一个线程池用于处理这些系统调用，最后完成结果的回收功能。

​	下面将详细说明在这些过程中，原版的具体实现以及移植中所做的更改。第四节则将会说明对uCore做的一些具体改动。



## 3. Executor 修改情况

### 起始进程

​	当executor开始运行的时候，会先依次建立以下几步操作，然后才开始创建sandbox：

​	首先是建立和Fuzzer的通信，关于这一点，linux版本和我们的版本有着很大的区别。在linux版本中，由于executor和fuzzer都运行于目标操作系统，executor是作为fuzzer子进程的形式出现的。而通过子进程共享的文件描述符（基于Copy-on-Write获得的特性），executor只需通过mmap就可以利用文件直接和fuzzer进行交流了。而在uCore版本中，executor和fuzzer运行于不同的两个操作系统中，他们的交流方式则是通过取自与kAFL的hypercall来实现的，因此在这儿要进行一些修改。关于两种不同通信方式的具体实现，详见我们的通信设计文档。

​	确定通信之后的下一件事也相当重要，它是为了解决一种特定的异常情况而出现的。在Syzkaller的测试中包含大量的内存测试，而由于内存地址普遍通过随机生成，因此很有可能会生成违法地址。考虑到效率等各方面的问题，executor的设计者并不希望直接因此导致测试的进程被杀死，而是希望通过类似于try/exception的方式，用自己设计的handler来处理这种情况。C不提供try机制，因此只能通过信号量来完成。幸运的是，uCore+包含信号量的功能，但在具体的异常处理过程中还需要使用longjmp/setjmp函数来完成跨函数的跳转，这一点并没有相应的实现。为求功能最小化，我们暂时删掉了这一功能，但我们已经了解了这两个函数的原理，会在之后将其完成。

​	接下来的步骤基本没有改动，直至开始建立sandbox进程。Syzkaller一共提供了三种不同的sandbox模式：sandbox-none、sandbox-uid、sandbox-namespace模式。这三种模式主要是为了通过隔离权限来防止不应当出现的错误（按照官方文档的说法，可以消除掉找出错误的bug，即false-positive），但是ucore根本没有用户组，也没有namespace隔离机制，所以我们直接采用了sandbox-none，直接生成sandbox进程。



### Sandbox进程

​	sandbox进程首先也会设定一些环境条件，涉及到cgroup、进程组、会话的操作，uCore版本中全部删去了，只保留了设置进程占用资源大小的操作。在环境准备完成之后，需要在已经建立起的通信pipe上和fuzzer进行握手，向其通知exetutor已经准备就绪。这点除通信方式外无需做改动。然后就可以开始处理由fuzzer发过来的execute了。

​	sandbox会进入不断的循环，每次建立起新的文件夹和execute进程，然后开始等待。一个execute对应的是一轮execute指令，如果等待的过程超时，它会将这个子进程杀死。无论如何，在execute进程关闭后，再由它负责向fuzzer回复execute执行完毕的信号，然后删除建立的文件夹，进入下一轮循环。循环的过程基本没有修改，但其中的一些部分和细节有着不小的改动（比如atomic操作，exeternal fuzzing等），这个之后会在提到。



### Execute进程

​	execute进程是一个相当复杂且重要的部分，它的执行步骤主要分为三个步骤：从execute输入中读取数据和指令；分配执行该指令的资源并执行；以及返回结果。第一部分主要涉及到通信和数据的读写，这点只需按照之前的方式修改即可。在执行指令的部分中，linux版本的程序采用了线程池的方法进行管理，一共采用了16个线程来运行不同的系统调用。也正因为这个缘故，它还可以对多线程运行中可能导致的数据竞争进行测试。uCore中虽然有多线程的库，但为了简化程序，我们先删除了这一部分功能。而对于最后的部分，主要的改动涉及到两方面，一个是返回什么样的结果，另一个则和代码覆盖相关，这些之后都会统一说明。

​	

​	以上是对于三个进程在运行步骤上的大致修改情况，但是除此之外还做了很多其它的改动，其中的一些相比上述的改动而言一点不小。这些改动需要单独拿出来进一步说民，一方面是因为贯穿了整个executor执行的过程，另一方面则是它们往往对应的是一整套功能。



### 代码覆盖功能：KCOV

​	KCOV是linux中已经集成的一个代码覆盖测试工具，能够通过DWARF调试信息进行代码覆盖率的测试。具体而言，含有KCOV的linux在编译的过程中，会在所有pc的跳转点（包括函数的开始、结束等等）设置一个__sanitizer_cov_trace_pc函数，这一函数在kernel/kcov.c中得以实现。当linux的镜像运行的时候，会不断地对这个函数进行访问，通过各段的节点获得代码覆盖的信息。除此之外，kcov模块在运行中的linux作为一个device，可以直接通过ioctl调用来进行相应的控制。

​	显然，作为教学操作系统的uCore自然不会拥有这样的工具，正因如此我们只能全盘放弃这一功能。在具体的代码中，一切含有"cover"的函数都与代码覆盖相关，我们一个也没放过。



### External fuzzing

​	Syzfuzzer的工程师在除了利用一般的系统调用以外，还提供了一种更加高端的fuzzing方式，即external fuzzing。这种fuzzing主要是针对较为复杂的应用场景，例如网络、挂载image等情况，在这些情况中，只通过系统调用来完成测试并不是一个明智的选择，因此对于这种情况，用于测试的函数直接写在了executor里面，然后fuzzer通过一个伪造的系统调用（原文如此）来将其激活并直接进行测试。这种测试太过于麻烦，且测试的对象和uCore的等级相比高上太多，虽然在Syzkaller已找到的bug中有很多都是通过这种方式找到的，但我们最终没有采用。

​	另外需要注意的是，Syzkaller对于网络的测试部分全都是通过这种方式完成的。因此除了external fuzzing的部分以外，网络相关的部分也没有保留下来（我们本来也就没有测试网络的意图）

​	P.S. 这一部分删去的代码有1000多行。



### Cgroups与权限管理

​	在executor中有很多涉及到权限管理的操作，例如chmod、unshare等，这些功能由于uCore并不包含，所以一个也没能活下来。而所谓Cgroups，也是linux中用于维持隔离和限制所采用的机制，很遗憾，这一点uCore也没有办法完成。



### 系统调用与错误号

​	在linux中，系统调用一旦发生错误，则会返回-1，同时将错误号记在名为errno的变量中（包含于errno.h）。但在uCore中，这种情况下errno会直接作为函数返回值返回。所以在处理函数调用错误的情况，也要将有errno的部分进行相应修改。



###文件系统

​	linux和uCore的文件系统基本一致，但有一点令人费解：uCore竟然没有提供rmdir函数（包括系统调用）！考虑到rmdir功能并不是十分重要，我们先暂时将rmdir的部分删去，但是之后还是会补上。

​	另外一点就是linux版本中采用了umount2函数，经过查询，得知这一点主要是为了暂时保留其他进程的文件描述符。这个操作uCore也没有提供支持。关于这个问题，我们的做法和rmdir同理。

​	最后就是mmap的操作。虽然uCore提供了mmap的支持，但是和linux的mmap却完全不是一个函数。不过奇妙的是，用户库中还提供了linux_mmap函数，因此这儿也需要修改一下函数名称。



###C++语法

​	linux版本的executor采用的是C++11，而uCore只支持C99语法，因此一些细节处需要修改。这其中首先要注意的是atomic操作，C++11直接提供了built-in函数__atomic，而按照C的标准，这一系列操作需要用户库提供函数和相应的数据结构来完成（atomic_t）。uCore提供了atomic的支持（虽然自己写也只需要一句内联汇编的功夫）。

​	其次是struct。executor并没有使用任何面向对象的编程，这一点减少了我们不少工作量，不过由于语法不同，在C语言的所有结构的声明前都需要加上struct关键字。

​	

## 4. uCore改动

​	关于uCore的改动主要集中在和系统调用直接相关的代码部分，而这其中修改较多的在用户库的部分。

​	事实上，在修改executor的过程中我们发现uCore的一些用户库函数是存在错误的，有的甚至完全不能运行。除了之前提到的mmap以外，例如waitpid函数等函数还存在着一些问题，其中还存在着一些。

​	另外，很多已经通过系统调用实现了的功能并没有在用户库当中得到实现，却在executor中被使用，这其中包括sertlimit、lstat等函数。我们将其统一进行了更新。也因为这个原因，一些需要使用的数据结构并没有在用户库中被定义，例如linux_lstat、linux_rlimit、sigset_t等，也都进行了更新。

​	对于用户库的主要修改就是这些，而对于kernel而言，针对一点做了较大的修改。可能是由于历史缘故，uCore中的系统调用分为两套：一套是uCore自带的系统调用，另一套则是linux标准下的部分系统调用。两套系统调用并不能通过同一种syscall方式来调用，为了解决这一问题我们将要使用的linux syscall都移到了常规syscall列表中，方便在executor使用。

​	还有一些修改虽然不大，但是十分重要，下面一一列举：

​	uCore提供的mmap（内存映射）操作不支持flag参数，但是在executor中需要使用一些参数，因此更改了sys_linux_mmap的部分实现，加入了对一些flag的支持；

​	（未完待续）	